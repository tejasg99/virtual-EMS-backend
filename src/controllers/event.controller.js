import mongoose, { isValidObjectId } from "mongoose";
import { Event } from "../models/event.model.js";
import { User } from "../models/user.model.js";
import { Registration } from "../models/registration.model.js";
import { ApiError } from "../utils/apiError.js";
import { ApiResponse } from "../utils/apiResponse.js";
import { asyncHandler } from "../utils/asyncHandler.js";

/**
 * @desc    Create a new event
 * @route   POST /api/v1/events
 * @access  Private (Organizer or Admin)
*/
const createEvent = asyncHandler(async(req, res) => {
    const {
        title,
        description,
        eventType,
        startTime,
        endTime,
        speakers, //should be an array of user objectIds
        maxAttendees,
    } = req.body;

    const organizerId = req.user?._id;
    const currentUserRole = req.user?.role; // Get current role

    if(!title || !description || !startTime || !endTime) {
        throw new ApiError(400, 'title, description, startTime and endTime are required');
    }

    //convert times to date objects for validation
    const start = new Date(startTime);
    const end = new Date(endTime);
    if(isNaN(start.getTime()) || isNaN(end.getTime())) {
        throw new ApiError(400, 'Invalid format for start or end time');
    }
    if(start >= end) {
        throw new ApiError(400, 'End time must be after start time');
    }
    //Prevent creating event in the past
    if(start < new Date()) {
        throw new ApiError(400, 'Start time cannot be in the past')
    }

    // Validate Speakers (Optional but good practice)
    let validSpeakerIds = [];
    if (speakers && Array.isArray(speakers) && speakers.length > 0) {
        // Check if speaker IDs are valid ObjectIds and correspond to actual users
        const speakerDocs = await User.find({
            _id: { $in: speakers },
            // role: { $in: ['speaker', 'organizer', 'admin'] } 
        }).select('_id'); // Only fetch IDs for validation

        validSpeakerIds = speakerDocs.map(doc => doc._id);
        // check if all provided speaker IDs were valid?
        if (validSpeakerIds.length !== speakers.length) {
        console.warn("Some provided speaker IDs were invalid or did not match users.");
        }
    }

    // Create Event instance (jitsiRoomName generated by model default)
    const eventData = {
        title,
        description,
        eventType, // Uses default if not provided and if defined in schema
        startTime: start,
        endTime: end,
        organizer: organizerId,
        maxAttendees,
        // status defaults to 'upcoming' 
    };

    // Only add the speakers array if it's not empty
    if (validSpeakerIds && validSpeakerIds.length > 0) {
        eventData.speakers = validSpeakerIds;
    }

    const event = new Event(eventData); // Pass the conditionally built object
    await event.save();

    // Update user role
    let roleUpdateMessage = '';
    if(currentUserRole === 'attendee') {
        try {
            const updatedUser = await User.findByIdAndUpdate(
                organizerId,
                { role: 'organizer'},
                { new: true } // Return updated user document
            );
            if(updatedUser) {
                console.log(`User ${updatedUser.email} promoted to organizer.`);
                roleUpdateMessage = ' Your role has been updated to Organizer.';
                // NOTE: The JWT token the user currently has *still* contains the OLD role ('attendee').
                // The role change will take effect on their *next* login or token refresh.
            } else {
                console.warn(`Could not find user ${organizerId} to update role after event creation.`);
            }
        } catch (roleUpdateError) {
            console.error(`Error updating user ${organizerId} role to organizer:`, roleUpdateError);
            // Log error but don't fail the event creation response
            roleUpdateMessage = ' Could not automatically update your role, please contact support if needed.';
        }
    }

    // Populate organizer/speaker details for the response
    const createdEvent = await Event.findById(event._id)
    .populate('organizer', 'name email role')
    .populate('speakers', 'name email');

    if (!createdEvent) {
        throw new ApiError(500, 'Failed to create an event');
    }

    return res
    .status(200)
    .json(new ApiResponse(200, createdEvent, `Event created successfully. ${roleUpdateMessage}`));
});

/**
 * @desc    Get all events with filtering, sorting, pagination
 * @route   GET /api/v1/events
 * @access  Public
*/
const getAllEvents = asyncHandler(async(req, res) => {
    const { status, eventType, sortBy = 'startTime', order = 'asc', page = 1, limit = 10 } = req.query;

    const filter = {};
    if(status) filter.status = status; //event status- upcoming, live, past
    if(eventType) filter.eventType = eventType;
    
    const sortOptions = {};
    if(sortBy) sortOptions[sortBy] = order === 'desc' ? -1: 1; //descending or ascending order

    const pageNum = parseInt(page, 10);
    const limitNum = parseInt(limit, 10);
    const skip = (pageNum - 1) * limitNum;
    
    //Query execution
    const events = await Event.find(filter)
    .populate('organizer', 'name email')
    //.populate('speakers', 'name email')
    .sort(sortOptions)
    .skip(skip)
    .limit(limitNum);

    //Get total count for pagination
    const totalEvents = await Event.countDocuments(filter);
    const totalPages = Math.ceil(totalEvents/limitNum);

    const pagination = {
        totalEvents,
        totalPages,
        currentPage: pageNum,
        limit: limitNum,
    }

    return res
    .status(200)
    .json(new ApiResponse(200, { events,  pagination }, 'Events fetched successfully'))
})

/**
 * @desc    Get a single event by ID
 * @route   GET /api/v1/events/:id
 * @access  Public
*/
const getEventById = asyncHandler(async(req, res) => {
    const { eventId } = req.params;

    if(!isValidObjectId(eventId)) {
        throw new ApiError(400, 'Invalid event ID');
    }
    
    const event = await Event.findById(eventId)
    .populate('organizer', 'name email') // Populate details
    .populate('speakers', 'name email');

    if (!event) {
        throw new ApiError(404, 'Event not found');
    }

    return res
    .status(200)
    .json(new ApiResponse(200, event, 'Event details fetched successfully'));
})

/**
 * @desc    Update an existing event
 * @route   PATCH /api/v1/events/:id
 * @access  Private (Original Organizer or Admin)
*/
const updateEvent = asyncHandler(async(req, res) => {
    const { eventId } = req.params;
    const userId = req.user?._id;
    const userRole = req.user?.role;
    const updateData = req.body;

    // Check if updateData is actually received
    if (!updateData || Object.keys(updateData).length === 0) {
        console.error('Error: req.body (updateData) is undefined or empty in updateEvent controller.');
        // Even if body parser is working, maybe frontend sent empty object?
        // Let's check Content-Length header from log above. If it's > 0 but body is undefined, it's a parser issue.
        throw new ApiError(400, 'No update data received.');
   }

    if(!isValidObjectId(eventId)) {
        throw new ApiError(400, 'Invalid event ID');
    }

    //find event
    const event = await Event.findById(eventId);
    if(!event) {
        throw new ApiError(404, 'Event not found')
    }

    //authorization check - must be an organizer or admin
    // Mongoose ObjectId comparison needs .equals() method
    if (!event.organizer.equals(userId) && userRole !== 'admin') {
        throw new ApiError(403, 'You do not have permission to update this event');
    }

    // Filter allowed fields for update (prevent changing organizer, jitsiRoomName etc.)
    const allowedUpdates = ['title', 'description', 'eventType', 'startTime', 'endTime', 'speakers', 'maxAttendees', 'status'];

    const filteredUpdateData = {};
    Object.keys(updateData).forEach(key => {
        if(allowedUpdates.includes(key)) {
            if (key === 'speakers' && !Array.isArray(updateData[key])) {
                // Skip invalid speaker format
               console.warn("Invalid format for speakers update, should be an array.");
               return; // Skip this key
           }
            if ((key === 'startTime' || key === 'endTime') && isNaN(new Date(updateData[key]).getTime())) {
                console.warn(`Invalid date format for ${key}`);
                return; // skip invalid date
            }
           filteredUpdateData[key] = updateData[key];
        }
    });

    // Validate start/end time logic if both are updated
    const newStartTime = filteredUpdateData.startTime ? new Date(filteredUpdateData.startTime) : event.startTime;
    const newEndTime = filteredUpdateData.endTime ? new Date(filteredUpdateData.endTime) : event.endTime;
    if (newStartTime >= newEndTime) {
        throw new ApiError(400, 'End time must be after start time');
    }
    filteredUpdateData.startTime = newStartTime; // Ensure Date objects are saved
    filteredUpdateData.endTime = newEndTime;

    // Perform the update
    const updatedEvent = await Event.findByIdAndUpdate(
        eventId,
        { $set: filteredUpdateData },
        { new: true, runValidators: true } // Return updated doc, run schema validators
    )
    .populate('organizer', 'name email')
    .populate('speakers', 'name email');

    if (!updatedEvent) {
        throw new ApiError(500, 'Failed to update the event');
    }

    return res
    .status(200)
    .json(new ApiResponse(200, updatedEvent, 'Event updated successfully'));
})

/**
 * @desc    Delete an event (changes status to 'cancelled')
 * @route   DELETE /api/v1/events/:id
 * @access  Private (Original Organizer or Admin)
*/
const deleteEvent = asyncHandler(async(req, res) => {
    const {eventId} = req.params;
    const userId = req.user?._id;
    const userRole = req.user.role;

    if(!isValidObjectId(eventId)) {
        throw new ApiError(400, 'Invalid event Id');
    }

    // Find the event
    const event = await Event.findById(eventId);
    if (!event) {
        throw new ApiError(404, 'Event not found');
    }

    // Authorization Check: Must be organizer or admin
    if (!event.organizer.equals(userId) && userRole !== 'admin') {
        throw new ApiError(403, 'You do not have permission to delete this event');
    }

    // Check if already cancelled
    if (event.status === 'cancelled') {
        return res
        .status(200)
        .json(new ApiResponse(200, event, 'Event is already cancelled'));
    }

    // Performing "Soft Delete" by updating status to 'cancelled' for now
    event.status = 'cancelled';
    await event.save({ validateBeforeSave: false });

    // TODO: Consider triggering notifications to registered users here or via an event listener

    return res
    .status(200)
    .json(new ApiResponse(200, event, 'Event cancelled successfully'));
})

/**
 * @desc    Get events organized by the current user with registration counts
 * @route   GET /api/v1/events/my-organized
 * @access  Private (Logged-in users)
*/
const getMyOrganizedEvents = asyncHandler(async (req, res) => {
    const organizerId = req.user._id;

    // Pagination Parameters
    const page = parseInt(req.query.page, 10) || 1;
    const limit = parseInt(req.query.limit, 10) || 10;
    const skip = (page - 1) * limit;

    // Sorting Parameters 
    const sortBy = req.query.sortBy || 'startTime'; // Default sort by start time
    const order = req.query.order === 'desc' ? -1 : 1;
    const sortOptions = { [sortBy]: order };

    // Filtering 
    // Find events where the organizer field matches the logged-in user's ID
    const filter = { organizer: organizerId };
    // Optionally add status filter if needed via query params
    if (req.query.status) {
        filter.status = req.query.status;
    }

    // Database Query 
    // Find the events organized by the user
    const events = await Event.find(filter)
        .sort(sortOptions)
        .skip(skip)
        .limit(limit)
        .lean(); // Use lean for performance if we're modifying the objects

    // Get total count for pagination
    const totalEvents = await Event.countDocuments(filter);

    // Add Registration Count to each event 
    // Use Promise.all to fetch counts concurrently
    const eventsWithCounts = await Promise.all(
        events.map(async (event) => {
            const registrationCount = await Registration.countDocuments({ event: event._id });
            return {
                ...event, // Spread the original event data
                registrationCount: registrationCount, // Add the count
            };
        })
    );

    // Pagination Metadata 
    const totalPages = Math.ceil(totalEvents / limit);
    const pagination = {
        totalEvents,
        totalPages,
        currentPage: page,
        limit,
    };

    // Structure Response 
    const responseData = {
        events: eventsWithCounts, // Use the events with counts added
        pagination,
    };

    return res
    .status(200)
    .json(new ApiResponse(200, responseData, 'Your organized events fetched successfully'));
});

/**
 * @desc    Get aggregate statistics for events organized by the current user
 * @route   GET /api/v1/events/my-organized/stats
 * @access  Private (Logged-in users)
*/
const getOrganizerStats = asyncHandler(async (req, res) => {
    const organizerId = req.user._id;

    // Use Promise.all to run aggregations concurrently
    const [stats] = await Promise.all([
        Event.aggregate([
            // Match events organized by the current user
            { $match: { organizer: new mongoose.Types.ObjectId(organizerId) } },
            // Group to calculate counts based on status
            {
                $group: {
                    _id: null, // Group all matched documents together
                    totalEvents: { $sum: 1 },
                    upcomingEvents: {
                        $sum: { $cond: [{ $eq: ['$status', 'upcoming'] }, 1, 0] }
                    },
                    liveEvents: {
                        $sum: { $cond: [{ $eq: ['$status', 'live'] }, 1, 0] }
                    },
                    pastEvents: {
                        $sum: { $cond: [{ $eq: ['$status', 'past'] }, 1, 0] }
                    },
                    cancelledEvents: {
                        $sum: { $cond: [{ $eq: ['$status', 'cancelled'] }, 1, 0] }
                    },
                    // Store the event IDs for the next stage
                    eventIds: { $push: '$_id' }
                }
            },
            // Lookup total registrations for the matched events
            {
                $lookup: {
                    from: 'registrations', // The name of the registrations collection
                    localField: 'eventIds', // Field from the previous stage (array of event IDs)
                    foreignField: 'event', // Field in the registrations collection to match against
                    as: 'allRegistrations' // Name of the new array field to add
                }
            },
            // Add a field for the total registration count
            {
                $addFields: {
                    totalRegistrations: { $size: '$allRegistrations' }
                }
            },
            // Project the final desired fields
            {
                $project: {
                    _id: 0, // Exclude the default _id field
                    totalEvents: 1,
                    upcomingEvents: 1,
                    liveEvents: 1,
                    pastEvents: 1,
                    cancelledEvents: 1,
                    totalRegistrations: 1
                }
            }
        ])
        // Add more concurrent queries here if needed (e.g., total attendees)
    ]);


    // Handle case where organizer has no events (aggregate returns empty array)
    const result = stats[0] || {
        totalEvents: 0,
        upcomingEvents: 0,
        liveEvents: 0,
        pastEvents: 0,
        cancelledEvents: 0,
        totalRegistrations: 0
    };

    return res.status(200).json(
        new ApiResponse(200, result, 'Organizer statistics fetched successfully')
    );
});



export {
    createEvent,
    getAllEvents,
    getEventById,
    updateEvent,
    deleteEvent,
    getMyOrganizedEvents,
    getOrganizerStats,
}